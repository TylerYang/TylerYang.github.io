<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Morris Traversal - Algorithm | TylerYang</title>
  <meta name="author" content="Tyler Yang">
  
  <meta name="description" content="Morris Traversal is a way to traverse the tree without using any extra space.
It is inspired by the Threaded Binary Tree. In threaded binary tree, with setting some extra pointers, it’s possible to cheaply find its successor.The Morris Traversal leverage the rightmost node, so the space complexity is O(1).Let’s see how it works.
The pseudo code of inorder Morris Traversal is listed below,

Initialize current as root
while current is not Null  If current doesn’t have left child
Print current’s data
Go to the right, i.e., current = current -&amp;gt; rightElse
Make current as right child of the rightmost node in current’s left sub tree
Go to this left child, i.e., current = current -&amp;gt; left">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Morris Traversal - Algorithm"/>
  <meta property="og:site_name" content="TylerYang"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="TylerYang" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
      var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?136f9d0455315c9611ba56b53088b6f9";
          var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">TylerYang</a></h1>
  <h2>
      <a href="/">
          Learning requires inefficiency
          
      </a>
  </h2>
</div>
<nav id="main-nav">
  <ul>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px">


</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
  
    <h1 class="title">Morris Traversal - Algorithm</h1>
  

      
        <p class="published">
          Published: <time datetime="2016-04-17T06:20:54.000Z">2016-04-17</time>
        </p>
      
    </header>
    <div class="entry">
      
        <p>Morris Traversal is a way to traverse the tree without using any extra space.</p>
<p>It is inspired by the <a href="https://en.wikipedia.org/wiki/Threaded_binary_tree" title="Threaded Binary Tree from wiki" target="_blank" rel="external">Threaded Binary Tree</a>. In threaded binary tree, with setting some extra pointers, it’s possible to cheaply find its successor.<br>The Morris Traversal leverage the rightmost node, so the space complexity is O(1).<br>Let’s see how it works.</p>
<p>The pseudo code of inorder Morris Traversal is listed below,</p>
<ul>
<li>Initialize current as root</li>
<li>while current is not Null<br>  <strong>If</strong> current doesn’t have left child<ul>
<li>Print current’s data</li>
<li>Go to the right, i.e., <code>current = current -&gt; right</code><br><strong>Else</strong></li>
<li>Make current as right child of the rightmost node in current’s left sub tree</li>
<li>Go to this left child, i.e., <code>current = current -&gt; left</code><a id="more"></a>
</li>
</ul>
</li>
</ul>
<p>Java Implementation,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">" "</span>);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode next = curr.left;</span><br><span class="line">            <span class="keyword">while</span> (next.right != <span class="keyword">null</span> &amp;&amp; next.right != curr) &#123;</span><br><span class="line">                next = next.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.right == <span class="keyword">null</span> &amp;&amp; next.right != curr) &#123;</span><br><span class="line">                next.right = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(curr.val + <span class="string">" "</span>);</span><br><span class="line">                next.right = <span class="keyword">null</span>;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The pseudo code of preorder Morris Traversal is listed below,</p>
<ul>
<li>Initialize current as root</li>
<li>while current is not Null<br>  <strong>If</strong> current doesn’t have left child<ul>
<li>Print current’s data</li>
<li>Go to the right, i.e., <code>current = current -&gt; right</code><br><strong>Else</strong></li>
<li>Make current as right child of the rightmost node in current’s left sub tree</li>
<li>Print current’s data</li>
<li>Go to this left child, i.e., <code>current = current -&gt; left</code></li>
</ul>
</li>
</ul>
<p>Java implementation,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(curr.val + <span class="string">" "</span>);</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode next = curr.left;</span><br><span class="line">            <span class="keyword">while</span> (next.right != <span class="keyword">null</span> &amp;&amp; next.right != curr) &#123;</span><br><span class="line">                next = next.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                next.right = curr;</span><br><span class="line">                System.out.print(curr.val + <span class="string">" "</span>);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">                next.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>As you can see, although we modified the tree during the traversal, we revert them back in the second round.</p>
<p>So for now we can know the advantages and the disadvantages,</p>
<ul>
<li><p>Advantages</p>
<ul>
<li>Avoid recursion or stack which decrease the space complexity.</li>
</ul>
</li>
<li><p>Disadvantages</p>
<ul>
<li>We can only make traversal at a time</li>
<li>More prone to errors, more difficult to implement, if we compare the the stack or recursive version</li>
</ul>
</li>
</ul>

      
    </div>
    <footer>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>
<!-- hackish -->

  

</div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 Tyler Yang
  
</div>
<div class="clearfix"></div></footer>
  <!--[if lt IE 9]><script src="/js/html5.js"></script><![endif]-->
<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script src="/js/tyleryang.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>